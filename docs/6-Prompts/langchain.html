
<!DOCTYPE html>


<html lang="zh-CN" data-content_root="../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-GESLLLJC6M"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-GESLLLJC6M');
    </script>
    
    <title>基于Langchain的提示词开发实践 &#8212; 人工智能实践 0.5 文档</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  <!-- 
    this give us a css class that will be invisible only if js is disabled 
  -->
  <noscript>
    <style>
      .pst-js-only { display: none !important; }

    </style>
  </noscript>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=26a4bc78f4c0ddb94549" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=26a4bc78f4c0ddb94549" rel="stylesheet" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=a746c00c" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/sphinx-book-theme.css?v=a3416100" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../_static/css/custom.css?v=be9b6ff4" />
  
  <!-- So that users can add custom icons -->
  <script src="../_static/scripts/fontawesome.js?digest=26a4bc78f4c0ddb94549"></script>
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=26a4bc78f4c0ddb94549" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=26a4bc78f4c0ddb94549" />

    <script src="../_static/documentation_options.js?v=cd8ec5f0"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../_static/copybutton.js?v=f281be69"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script src="../_static/translations.js?v=beaddf03"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '6-Prompts/langchain';</script>
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="提示词案例分析" href="good-examples.html" />
    <link rel="prev" title="提示词案例分析" href="prompts-examples.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="zh-CN"/>
  <meta name="docsearch:version" content="" />
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <dialog id="pst-search-dialog">
    
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         placeholder="Search..."
         aria-label="Search..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
  </dialog>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <dialog id="pst-primary-sidebar-modal"></dialog>
      <div id="pst-primary-sidebar" class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../index.html">
  
  
  
  
  
  
    <p class="title logo__title">人工智能实践 0.5 文档</p>
  
</a></div>
        <div class="sidebar-primary-item">

<button class="btn search-button-field search-button__button pst-js-only" title="搜索" aria-label="搜索" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">搜索</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">课程简介</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../1-Intro/intro.html">课程大纲</a></li>
<li class="toctree-l1"><a class="reference internal" href="../1-Intro/resources.html">资源</a></li>
<li class="toctree-l1"><a class="reference internal" href="../1-Intro/terms.html">术语</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">大模型基础</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../2-Basics/setup.html">环境准备</a></li>
<li class="toctree-l1"><a class="reference internal" href="../2-Basics/llm-basics.html">LLM 基础</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">基于Transformer的自然语言处理</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../3-Practice/nlp-tasks.html">NLP 任务</a></li>
<li class="toctree-l1"><a class="reference internal" href="../3-Practice/transformer-nlp.html">基于HF Transformer的NLP实践</a></li>
<li class="toctree-l1"><a class="reference internal" href="../3-Practice/classification.html">文本分类</a></li>
<li class="toctree-l1"><a class="reference internal" href="../3-Practice/clusttering.html">文档聚类</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">语言学基础</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../4-Linguistics/linguistics-llm.html">大语言模型与语言学</a></li>
<li class="toctree-l1"><a class="reference internal" href="../4-Linguistics/llm-metrics.html">常见大模型评价指标</a></li>
<li class="toctree-l1"><a class="reference internal" href="../4-Linguistics/translation-metrics.html">译文质量评价方法</a></li>
<li class="toctree-l1"><a class="reference internal" href="../4-Linguistics/linguistics-intro.html">语言学简介</a></li>
<li class="toctree-l1"><a class="reference internal" href="../4-Linguistics/applied-linguistics.html">应用语言学</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">课程实践项目</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../5-Projects/projects.html">课程实践项目要求</a></li>
<li class="toctree-l1"><a class="reference internal" href="../5-Projects/evaluating-llms.html">大模型的评估与选择</a></li>
<li class="toctree-l1"><a class="reference internal" href="../5-Projects/evaluate-case.html">评价模型翻译能力</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">提示词</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="prompts-intro.html">提示词导论</a></li>
<li class="toctree-l1"><a class="reference internal" href="prompts-examples.html">提示词案例分析</a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#">基于Langchain的提示词开发实践</a></li>
<li class="toctree-l1"><a class="reference internal" href="good-examples.html">提示词案例分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="jail-break.html">提示词越狱</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">微调</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../fine-tunning/ft-gen-models.html">微调生成式大模型</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fine-tunning/mlm-bert.html">使用MLM微调Bert模型</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fine-tunning/ft-phi4.html">SFT 微调 Phi-4</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fine-tunning/ft-ph4-self.html">练习：使用自监督学习微调Phi4-mini</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fine-tunning/ft-rl.html">基于人类反馈微调大模型（RLHF + DPO）</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">参考答案</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../answers/transformer-practice-answers.html">基于HF Transformer的NLP实践的练习答案</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="下载此页面">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../_sources/6-Prompts/langchain.md" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="下载源文件"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.md</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="列印成 PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="全屏模式"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button>


<button class="btn btn-sm pst-navbar-icon search-button search-button__button pst-js-only" title="搜索" aria-label="搜索" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
</button>
<button class="sidebar-toggle secondary-toggle btn btn-sm" title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</button>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>基于Langchain的提示词开发实践</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> 目录 </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id1">LangChain简介</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id2">安装与准备</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id3">LangChain 提示词模板</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id4">为什么使用LangChain</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#langchain-lcel">LangChain 表达式语言（LCEL）</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#prompttemplate">在聊天模型中使用 PromptTemplate</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id5">输出解析器</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#openai-json">openai 原生支持json输出</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#langchain-evals">LangChain Evals</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#openai">OpenAI 函数调用</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#prompt-chaining">Prompt Chaining</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#sequential-chain">Sequential Chain</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#document-chains">Document Chains</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id6">参考</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section id="langchain">
<h1>基于Langchain的提示词开发实践<a class="headerlink" href="#langchain" title="Link to this heading">#</a></h1>
<section id="id1">
<h2>LangChain简介<a class="headerlink" href="#id1" title="Link to this heading">#</a></h2>
<p>LangChain 是一个开源框架，旨在简化和加速基于大型语言模型 (LLM) 的应用程序开发。它提供了一整套工具和模块，使开发者可以轻松地将语言模型与外部数据源、API、甚至自主决策机制相结合，从而实现数据增强和智能化功能。LangChain 同时支持 Python 和 TypeScript 版本，让不同技术栈的开发者都能利用这一框架快速构建高效、灵活的 AI 应用。其核心理念在于不仅仅将语言模型作为简单的 API 接口使用，而是通过丰富的功能扩展，打造出更加智能和具有自主决策能力的应用程序。</p>
<section id="id2">
<h3>安装与准备<a class="headerlink" href="#id2" title="Link to this heading">#</a></h3>
<p>如果是在本地运行，建议用虚拟环境。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>!pip install langchain langchain-openai
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">langchain_openai.chat_models</span> <span class="kn">import</span> <span class="n">ChatOpenAI</span>
<span class="kn">from</span> <span class="nn">google.colab</span> <span class="kn">import</span> <span class="n">userdata</span>
<span class="kn">from</span> <span class="nn">langchain_openai.chat_models</span> <span class="kn">import</span> <span class="n">ChatOpenAI</span>
<span class="kn">from</span> <span class="nn">langchain.schema</span> <span class="kn">import</span> <span class="n">AIMessage</span><span class="p">,</span> <span class="n">HumanMessage</span><span class="p">,</span> <span class="n">SystemMessage</span>

<span class="c1"># Instantiate ChatOpenAI with the desired settings</span>
<span class="n">chat</span> <span class="o">=</span> <span class="n">ChatOpenAI</span><span class="p">(</span>
    <span class="n">temperature</span><span class="o">=</span><span class="mf">0.6</span><span class="p">,</span>
    <span class="n">model</span><span class="o">=</span><span class="s2">&quot;gpt-4o&quot;</span><span class="p">,</span>  <span class="c1"># Correctly specify the model name (ensure the model name is valid)</span>
    <span class="n">api_key</span><span class="o">=</span><span class="n">userdata</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;OPENAI_API_KEY&#39;</span><span class="p">)</span>
<span class="p">)</span>

<span class="c1"># Define the conversation messages</span>
<span class="n">messages</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">SystemMessage</span><span class="p">(</span><span class="n">content</span><span class="o">=</span><span class="s2">&quot;Act as a senior software engineer at a startup company.&quot;</span><span class="p">),</span>
    <span class="n">HumanMessage</span><span class="p">(</span><span class="n">content</span><span class="o">=</span><span class="s2">&quot;Please can you provide a funny joke about software engineers?&quot;</span><span class="p">)</span>
<span class="p">]</span>

<span class="c1"># Invoke the chat model using the provided messages</span>
<span class="n">response</span> <span class="o">=</span> <span class="n">chat</span><span class="o">.</span><span class="n">invoke</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="n">messages</span><span class="p">)</span>

<span class="c1"># Print the response content</span>
<span class="nb">print</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">content</span><span class="p">)</span>

</pre></div>
</div>
<blockquote>
<div><p>如果不指定 model，ChatOpenAI 默认会使用 “gpt-3.5-turbo” 模型。</p>
</div></blockquote>
<p>输出：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Sure, here&#39;s one for you:

Why do software engineers prefer dark mode?

Because light attracts bugs!
</pre></div>
</div>
</section>
</section>
<section id="id3">
<h2>LangChain 提示词模板<a class="headerlink" href="#id3" title="Link to this heading">#</a></h2>
<p>提示词通常都是使用f-string写：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">language</span> <span class="o">=</span> <span class="s2">&quot;Python&quot;</span>
<span class="n">prompt</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;What is the best way to learn coding in </span><span class="si">{</span><span class="n">language</span><span class="si">}</span><span class="s2">?&quot;</span>
<span class="nb">print</span><span class="p">(</span><span class="n">prompt</span><span class="p">)</span> 

<span class="c1"># What is the best way to learn coding in Python?</span>
</pre></div>
</div>
<section id="id4">
<h3>为什么使用LangChain<a class="headerlink" href="#id4" title="Link to this heading">#</a></h3>
<p>为什么不直接使用 f-string 来进行提示模板化呢，因为用 LangChain 的提示模板能轻松做到以下几点：</p>
<ul class="simple">
<li><p>验证你的提示输入</p></li>
<li><p>通过组合，将多个提示词整合</p></li>
<li><p>自定义选择器，将 k-shot 示例注入到提示中</p></li>
<li><p>从 .yml 和 .json 文件中保存和加载提示词</p></li>
<li><p>创建在生成时可以执行额外代码或指令的自定义提示模板</p></li>
</ul>
</section>
<section id="langchain-lcel">
<h3>LangChain 表达式语言（LCEL）<a class="headerlink" href="#langchain-lcel" title="Link to this heading">#</a></h3>
<p>LangChain 表达式语言（LangChain Expression Language, LCEL） 中 “|” 管道运算符是 LCEL 的关键组件，它可将数据处理流水线中不同的组件（或可运行单元）串联在一起。</p>
<p>在 LCEL 中，“|” 运算符类似于 Unix 管道运算符：它将一个组件的输出作为输入传递给链中下一个组件，从而让你可以轻松地连接和组合不同的组件，创建出复杂的操作链。</p>
<p>例如：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">chain</span> <span class="o">=</span> <span class="n">prompt</span> <span class="o">|</span> <span class="n">model</span>
</pre></div>
</div>
<p>这里，“|” 运算符用于将 prompt 和 model 组件串联在一起。prompt 组件的输出会传递给 model 组件。这种链式机制使你可以从基本组件构建复杂的链，并实现数据在处理流水线各阶段之间的无缝流动。</p>
<p>另外，顺序非常重要，理论上你也可以构造如下链：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">bad_order_chain</span> <span class="o">=</span> <span class="n">model</span> <span class="o">|</span> <span class="n">prompt</span>
</pre></div>
</div>
<p>但在调用 invoke 函数时会产生错误，因为 model 返回的值与 prompt 所期望的输入不兼容。</p>
<p>接下来，让我们使用提示模板创建一个商业名称生成器，该生成器将返回五到七个相关的商业名称。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">langchain_openai.chat_models</span> <span class="kn">import</span> <span class="n">ChatOpenAI</span>
<span class="kn">from</span> <span class="nn">langchain_core.prompts</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">SystemMessagePromptTemplate</span><span class="p">,</span>
    <span class="n">ChatPromptTemplate</span>
<span class="p">)</span>

<span class="n">template</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">You are a creative consultant brainstorming names for businesses.</span>
<span class="s2">You must follow the following principles:</span>
<span class="si">{principles}</span>
<span class="s2">Please generate a numerical list of five catchy names for a start-up in the</span>
<span class="si">{industry}</span><span class="s2"> industry that deals with </span><span class="si">{context}</span><span class="s2">?</span>
<span class="s2">Here is an example of the format:</span>
<span class="s2">1. Name1</span>
<span class="s2">2. Name2</span>
<span class="s2">3. Name3</span>
<span class="s2">4. Name4</span>
<span class="s2">5. Name5</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="n">model</span> <span class="o">=</span> <span class="n">ChatOpenAI</span><span class="p">(</span>
    <span class="n">temperature</span><span class="o">=</span><span class="mf">0.6</span><span class="p">,</span>
    <span class="n">model</span><span class="o">=</span><span class="s2">&quot;gpt-4o&quot;</span><span class="p">,</span>  <span class="c1"># Correctly specify the model name (ensure the model name is valid)</span>
    <span class="n">api_key</span><span class="o">=</span><span class="n">userdata</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;OPENAI_API_KEY&#39;</span><span class="p">)</span>
<span class="p">)</span>

<span class="n">system_prompt</span> <span class="o">=</span> <span class="n">SystemMessagePromptTemplate</span><span class="o">.</span><span class="n">from_template</span><span class="p">(</span><span class="n">template</span><span class="p">)</span>
<span class="n">chat_prompt</span> <span class="o">=</span> <span class="n">ChatPromptTemplate</span><span class="o">.</span><span class="n">from_messages</span><span class="p">([</span><span class="n">system_prompt</span><span class="p">])</span>
<span class="n">chain</span> <span class="o">=</span> <span class="n">chat_prompt</span> <span class="o">|</span> <span class="n">model</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">chain</span><span class="o">.</span><span class="n">invoke</span><span class="p">({</span>
    <span class="s2">&quot;industry&quot;</span><span class="p">:</span> <span class="s2">&quot;medical&quot;</span><span class="p">,</span>
    <span class="s2">&quot;context&quot;</span><span class="p">:</span> <span class="s1">&#39;&#39;&#39;creating AI solutions by automatically summarizing patient records&#39;&#39;&#39;</span><span class="p">,</span>
    <span class="s2">&quot;principles&quot;</span><span class="p">:</span> <span class="s1">&#39;&#39;&#39;1. Each name should be short and easy to remember.</span>
<span class="s1">2. Each name should be easy to pronounce.</span>
<span class="s1">3. Each name should be unique and not already taken by another company.&#39;&#39;&#39;</span>
<span class="p">})</span>

<span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">content</span><span class="p">)</span>

</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mf">1.</span> <span class="n">MedBrief</span>
<span class="mf">2.</span> <span class="n">HealthSynth</span>
<span class="mf">3.</span> <span class="n">RecordWise</span>
<span class="mf">4.</span> <span class="n">SummarAIze</span>
<span class="mf">5.</span> <span class="n">ChartGenius</span>
</pre></div>
</div>
</section>
</section>
<section id="prompttemplate">
<h2>在聊天模型中使用 PromptTemplate<a class="headerlink" href="#prompttemplate" title="Link to this heading">#</a></h2>
<p>LangChain 提供了一种更传统的模板，称为 PromptTemplate，它需要传入 input_variables 和 template 参数。</p>
<p>输入：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">langchain_core.prompts</span> <span class="kn">import</span> <span class="n">PromptTemplate</span>
<span class="kn">from</span> <span class="nn">langchain.prompts.chat</span> <span class="kn">import</span> <span class="n">SystemMessagePromptTemplate</span>
<span class="kn">from</span> <span class="nn">langchain_openai.chat_models</span> <span class="kn">import</span> <span class="n">ChatOpenAI</span>

<span class="n">prompt</span> <span class="o">=</span> <span class="n">PromptTemplate</span><span class="p">(</span>
    <span class="n">template</span><span class="o">=</span><span class="s1">&#39;&#39;&#39;You are a helpful assistant that translates </span><span class="si">{input_language}</span><span class="s1"> to </span><span class="si">{output_language}</span><span class="s1">.&#39;&#39;&#39;</span><span class="p">,</span>
    <span class="n">input_variables</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;input_language&quot;</span><span class="p">,</span> <span class="s2">&quot;output_language&quot;</span><span class="p">],</span>
<span class="p">)</span>
<span class="n">system_message_prompt</span> <span class="o">=</span> <span class="n">SystemMessagePromptTemplate</span><span class="p">(</span><span class="n">prompt</span><span class="o">=</span><span class="n">prompt</span><span class="p">)</span>
<span class="n">chat</span> <span class="o">=</span> <span class="n">ChatOpenAI</span><span class="p">()</span>
<span class="n">chat</span><span class="o">.</span><span class="n">invoke</span><span class="p">(</span><span class="n">system_message_prompt</span><span class="o">.</span><span class="n">format_messages</span><span class="p">(</span>
    <span class="n">input_language</span><span class="o">=</span><span class="s2">&quot;English&quot;</span><span class="p">,</span> <span class="n">output_language</span><span class="o">=</span><span class="s2">&quot;French&quot;</span><span class="p">))</span>
</pre></div>
</div>
<p>输出：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">AIMessage</span><span class="p">(</span><span class="n">content</span><span class="o">=</span><span class="s2">&quot;Vous êtes un assistant utile qui traduit l&#39;anglais en français.&quot;</span><span class="p">,</span> <span class="n">additional_kwargs</span><span class="o">=</span><span class="p">{},</span> <span class="n">example</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="id5">
<h2>输出解析器<a class="headerlink" href="#id5" title="Link to this heading">#</a></h2>
<p>输出解析器是 LangChain 提供的一种高级抽象，用于从大型语言模型（LLM）的字符串响应中解析结构化数据。通常我们需要使用正则表达式（regex）从文本中提取结构化数据，但在 LangChain 中可以通过输出解析器自动完成这一操作。</p>
<p>目前可用的输出解析器包括：</p>
<ul class="simple">
<li><p>列表解析器 (List parser)。返回一个由逗号分隔的项目列表。</p></li>
<li><p>日期时间解析器 (Datetime parser)。将 LLM 的输出解析为日期时间格式。</p></li>
<li><p>枚举解析器 (Enum parser)。将字符串解析为枚举值。</p></li>
<li><p>自动修正解析器 (Auto-fixing parser)。封装另一个输出解析器，如果该输出解析器失败，则调用另一个 LLM 来修正错误。</p></li>
<li><p>Pydantic（JSON）解析器 (Pydantic (JSON) parser)。将 LLM 的响应解析为符合 Pydantic 模式的 JSON 输出。</p></li>
<li><p>Retry parser (Retry parser)。提供对前一个输出解析器解析失败的重试。</p></li>
<li><p>Structured output parser (Structured output parser)。可用于返回多个字段的解析结果。</p></li>
<li><p>XML parser (XML parser)。将 LLM 的响应解析为基于 XML 的格式。</p></li>
<li><p>.get_format_instructions()。该函数为你的提示提供输出可解析的结构化格式所需的说明。</p></li>
<li><p>.parse(llm_output: str)。该函数负责将 LLM 的响应解析为预定义的格式。</p></li>
</ul>
<p>输入：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">langchain_core.prompts.chat</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">ChatPromptTemplate</span><span class="p">,</span>
    <span class="n">SystemMessagePromptTemplate</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">langchain_openai.chat_models</span> <span class="kn">import</span> <span class="n">ChatOpenAI</span>
<span class="kn">from</span> <span class="nn">langchain.output_parsers</span> <span class="kn">import</span> <span class="n">PydanticOutputParser</span>
<span class="kn">from</span> <span class="nn">pydantic.v1</span> <span class="kn">import</span> <span class="n">BaseModel</span><span class="p">,</span> <span class="n">Field</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>

<span class="n">temperature</span> <span class="o">=</span> <span class="mf">0.0</span>

<span class="k">class</span> <span class="nc">BusinessName</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">description</span><span class="o">=</span><span class="s2">&quot;The name of the business&quot;</span><span class="p">)</span>
    <span class="n">rating_score</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">description</span><span class="o">=</span><span class="s1">&#39;&#39;&#39;The rating score of the</span>
<span class="s1">    business. 0 is the worst, 10 is the best.&#39;&#39;&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">BusinessNames</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
    <span class="n">names</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">BusinessName</span><span class="p">]</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">description</span><span class="o">=</span><span class="s1">&#39;&#39;&#39;A list</span>
<span class="s1">    of business names&#39;&#39;&#39;</span><span class="p">)</span>

<span class="c1"># 设置解析器并将指令注入到提示模板中：</span>
<span class="n">parser</span> <span class="o">=</span> <span class="n">PydanticOutputParser</span><span class="p">(</span><span class="n">pydantic_object</span><span class="o">=</span><span class="n">BusinessNames</span><span class="p">)</span>

<span class="n">principles</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">- The name must be easy to remember.</span>
<span class="s2">- Use the </span><span class="si">{industry}</span><span class="s2"> industry and Company context to create an effective name.</span>
<span class="s2">- The name must be easy to pronounce.</span>
<span class="s2">- You must only return the name without any other text or characters.</span>
<span class="s2">- Avoid returning full stops, </span><span class="se">\n</span><span class="s2">, or any other characters.</span>
<span class="s2">- The maximum length of the name must be 10 characters.</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="c1"># 聊天模型输出解析器：</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">ChatOpenAI</span><span class="p">()</span>
<span class="n">template</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;Generate five business names for a new start-up company in the</span>
<span class="si">{industry}</span><span class="s2"> industry.</span>
<span class="s2">You must follow the following principles: </span><span class="si">{principles}</span>
<span class="si">{format_instructions}</span>
<span class="s2">&quot;&quot;&quot;</span>
<span class="n">system_message_prompt</span> <span class="o">=</span> <span class="n">SystemMessagePromptTemplate</span><span class="o">.</span><span class="n">from_template</span><span class="p">(</span><span class="n">template</span><span class="p">)</span>
<span class="n">chat_prompt</span> <span class="o">=</span> <span class="n">ChatPromptTemplate</span><span class="o">.</span><span class="n">from_messages</span><span class="p">([</span><span class="n">system_message_prompt</span><span class="p">])</span>

<span class="c1"># 创建 LCEL 链：</span>
<span class="n">prompt_and_model</span> <span class="o">=</span> <span class="n">chat_prompt</span> <span class="o">|</span> <span class="n">model</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">prompt_and_model</span><span class="o">.</span><span class="n">invoke</span><span class="p">(</span>
    <span class="p">{</span>
        <span class="s2">&quot;principles&quot;</span><span class="p">:</span> <span class="n">principles</span><span class="p">,</span>
        <span class="s2">&quot;industry&quot;</span><span class="p">:</span> <span class="s2">&quot;Data Science&quot;</span><span class="p">,</span>
        <span class="s2">&quot;format_instructions&quot;</span><span class="p">:</span> <span class="n">parser</span><span class="o">.</span><span class="n">get_format_instructions</span><span class="p">(),</span>
    <span class="p">}</span>
<span class="p">)</span>

<span class="c1"># 输出解析器，将 LLM 响应解析为 Pydantic 对象：</span>
<span class="nb">print</span><span class="p">(</span><span class="n">parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">content</span><span class="p">))</span>

</pre></div>
</div>
<p>输出：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="n">BusinessName</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;DataWiz&#39;</span><span class="p">,</span> <span class="n">rating_score</span><span class="o">=</span><span class="mf">8.5</span><span class="p">),</span>
<span class="n">BusinessName</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;InsightIQ&#39;</span><span class="p">,</span>
<span class="n">rating_score</span><span class="o">=</span><span class="mf">9.2</span><span class="p">),</span> <span class="n">BusinessName</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;AnalytiQ&#39;</span><span class="p">,</span> <span class="n">rating_score</span><span class="o">=</span><span class="mf">7.8</span><span class="p">),</span>
<span class="n">BusinessName</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;SciData&#39;</span><span class="p">,</span> <span class="n">rating_score</span><span class="o">=</span><span class="mf">8.1</span><span class="p">),</span>
<span class="n">BusinessName</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;InfoMax&#39;</span><span class="p">,</span> <span class="n">rating_score</span><span class="o">=</span><span class="mf">9.5</span><span class="p">)]</span>
</pre></div>
</div>
<p>加载必要库之后，你将设置一个 ChatOpenAI 模型。接着，从你的模板中创建 SystemMessagePromptTemplate，并以此构建一个 ChatPromptTemplate。你将使用 Pydantic 模型 BusinessName 和 BusinessNames 来构建所期望的输出结构——一个包含唯一商业名称的列表。随后，你会创建一个用于解析这些模型的 Pydantic 解析器，并通过调用 invoke 函数，利用用户输入的变量来格式化提示。将这个定制的提示传递给模型后，你就能利用解析器使模型生成具有创造性且独特的商业名称。</p>
<p>可以通过以下语法在 LCEL 中使用输出解析器：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">chain</span> <span class="o">=</span> <span class="n">prompt</span> <span class="o">|</span> <span class="n">model</span> <span class="o">|</span> <span class="n">output_parser</span>
</pre></div>
</div>
<p>让我们将输出解析器直接添加到链中。</p>
<p><strong>输入：</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">parser</span> <span class="o">=</span> <span class="n">PydanticOutputParser</span><span class="p">(</span><span class="n">pydantic_object</span><span class="o">=</span><span class="n">BusinessNames</span><span class="p">)</span>
<span class="n">chain</span> <span class="o">=</span> <span class="n">chat_prompt</span> <span class="o">|</span> <span class="n">model</span> <span class="o">|</span> <span class="n">parser</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">chain</span><span class="o">.</span><span class="n">invoke</span><span class="p">(</span>
    <span class="p">{</span>
        <span class="s2">&quot;principles&quot;</span><span class="p">:</span> <span class="n">principles</span><span class="p">,</span>
        <span class="s2">&quot;industry&quot;</span><span class="p">:</span> <span class="s2">&quot;Data Science&quot;</span><span class="p">,</span>
        <span class="s2">&quot;format_instructions&quot;</span><span class="p">:</span> <span class="n">parser</span><span class="o">.</span><span class="n">get_format_instructions</span><span class="p">(),</span>
    <span class="p">}</span>
<span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</pre></div>
</div>
<p>输出：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="n">BusinessName</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;DataTech&#39;</span><span class="p">,</span> <span class="n">rating_score</span><span class="o">=</span><span class="mf">9.5</span><span class="p">),</span> <span class="o">...</span><span class="p">]</span>
</pre></div>
</div>
<p>值得注意的是，要求 LLM 提供结构化的 JSON 输出后，你可以从 LLM 的响应中构建一个灵活且通用的 API。虽然这种方式存在一些局限性，例如生成的 JSON 大小以及提示词的可靠性，但它仍然是 LLM 应用的一个非常有前景的领域。</p>
<p>输出解析器让你不必再处理正则表达式的复杂性和繁琐性，提供了多种易于使用的功能以满足各种需求。既然你已经看到了它们的实际应用，就可以利用输出解析器轻松地构建并提取所需数据，从 LLM 的输出中充分发挥 AI 的潜力来完成任务。</p>
<p>此外，通过使用解析器对从 LLM 中提取的数据进行结构化，你可以轻松地选择如何组织输出以实现更高效的使用。如果你处理大量列表，并且需要按照某些标准（例如商业名称）对它们进行排序，这将非常有用。</p>
<section id="openai-json">
<h3>openai 原生支持json输出<a class="headerlink" href="#openai-json" title="Link to this heading">#</a></h3>
<p>输入（ChatGPT o3-mini）：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>请对以下文本进行实体识别，并以 JSON 格式返回结果：

&quot;Barack Obama was born in Hawaii. He was the 44th president of the United States.&quot;
</pre></div>
</div>
<p>输出：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="s2">&quot;entities&quot;</span><span class="p">:</span> <span class="p">[</span>
    <span class="p">{</span>
      <span class="s2">&quot;text&quot;</span><span class="p">:</span> <span class="s2">&quot;Barack Obama&quot;</span><span class="p">,</span>
      <span class="s2">&quot;label&quot;</span><span class="p">:</span> <span class="s2">&quot;PERSON&quot;</span>
    <span class="p">},</span>
    <span class="p">{</span>
      <span class="s2">&quot;text&quot;</span><span class="p">:</span> <span class="s2">&quot;Hawaii&quot;</span><span class="p">,</span>
      <span class="s2">&quot;label&quot;</span><span class="p">:</span> <span class="s2">&quot;LOCATION&quot;</span>
    <span class="p">},</span>
    <span class="p">{</span>
      <span class="s2">&quot;text&quot;</span><span class="p">:</span> <span class="s2">&quot;United States&quot;</span><span class="p">,</span>
      <span class="s2">&quot;label&quot;</span><span class="p">:</span> <span class="s2">&quot;LOCATION&quot;</span>
    <span class="p">}</span>
  <span class="p">]</span>
<span class="p">}</span>

</pre></div>
</div>
</section>
</section>
<section id="langchain-evals">
<h2>LangChain Evals<a class="headerlink" href="#langchain-evals" title="Link to this heading">#</a></h2>
<p>除了使用输出解析器检查格式错误之外，大多数 AI 系统还会使用 evals 或评价指标来衡量每个提示响应的性能。LangChain 提供了许多开箱即用的评估器，这些评估器可以直接在其 LangSmith 平台中记录，以便进行进一步的调试、监控和测试。Weights and Biases 是另一种提供类似功能和追踪能力的机器学习平台，适用于 LLMs。</p>
<p>评价指标不仅对提示测试有用，还可用于识别检索的正面和负面示例，以及构建用于微调自定义模型的数据集。</p>
<p>大多数评价指标依赖于一组测试用例，这些测试用例是一组已知正确答案的输入输出配对。通常，这些参考答案是由人手动创建或策划的，但使用更智能的模型（如 GPT-4）生成真实答案也是一种常见做法，以下示例中便采用了这种方法。给定一组关于金融交易的描述，我们使用 GPT-4 对每笔交易进行分类，指定 transaction_category 和 transaction_type。</p>
<p>由于将 GPT-4 的答案视为正确答案，现在可以评估较小模型（例如 GPT-3.5-turbo 和 Mixtral 8x7b，在 API 中称为 mistral-small）的准确性。如果较小模型的准确性足够高，你就可以节省成本或降低延迟。此外，如果该模型是开源的（例如 Mistral 的模型），你可以将任务迁移到自己的服务器上运行，从而避免将可能敏感的数据发送到组织外部。</p>
<p>我们建议先使用外部 API 进行测试，然后再考虑自建开源模型。</p>
<p>记得注册并订阅以获取 API 密钥；然后在终端中将其作为环境变量暴露：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nb">export</span><span class="w"> </span><span class="nv">MISTRAL_API_KEY</span><span class="o">=</span>api-key
</pre></div>
</div>
<p>下面的脚本是一个笔记本的一部分，该笔记本之前已经定义了一个 DataFrame df。为了简洁起见，我们只研究脚本的评估部分，假设 DataFrame 已经定义。</p>
<p>输入：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">langchain_mistralai.chat_models</span> <span class="kn">import</span> <span class="n">ChatMistralAI</span>
<span class="kn">from</span> <span class="nn">langchain.output_parsers</span> <span class="kn">import</span> <span class="n">PydanticOutputParser</span>
<span class="kn">from</span> <span class="nn">langchain_core.prompts</span> <span class="kn">import</span> <span class="n">ChatPromptTemplate</span>
<span class="kn">from</span> <span class="nn">pydantic.v1</span> <span class="kn">import</span> <span class="n">BaseModel</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Literal</span><span class="p">,</span> <span class="n">Union</span>
<span class="kn">from</span> <span class="nn">langchain_core.output_parsers</span> <span class="kn">import</span> <span class="n">StrOutputParser</span>

<span class="c1"># 1. 定义模型:</span>
<span class="n">mistral_api_key</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s2">&quot;MISTRAL_API_KEY&quot;</span><span class="p">]</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">ChatMistralAI</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="s2">&quot;mistral-small&quot;</span><span class="p">,</span> <span class="n">mistral_api_key</span><span class="o">=</span><span class="n">mistral_api_key</span><span class="p">)</span>

<span class="c1"># 2. 定义提示:</span>
<span class="n">system_prompt</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;You are are an expert at analyzing</span>
<span class="s2">bank transactions, you will be categorizing a single</span>
<span class="s2">transaction.</span>
<span class="s2">Always return a transaction type and category:</span>
<span class="s2">do not return None.</span>
<span class="s2">Format Instructions:</span>
<span class="si">{format_instructions}</span><span class="s2">&quot;&quot;&quot;</span>
<span class="n">user_prompt</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;Transaction Text:</span>
<span class="si">{transaction}</span><span class="s2">&quot;&quot;&quot;</span>
<span class="n">prompt</span> <span class="o">=</span> <span class="n">ChatPromptTemplate</span><span class="o">.</span><span class="n">from_messages</span><span class="p">([</span>
    <span class="p">(</span><span class="s2">&quot;system&quot;</span><span class="p">,</span> <span class="n">system_prompt</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;user&quot;</span><span class="p">,</span> <span class="n">user_prompt</span><span class="p">)</span>
<span class="p">])</span>

<span class="c1"># 3. 定义 Pydantic 模型:</span>
<span class="k">class</span> <span class="nc">EnrichedTransactionInformation</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
    <span class="n">transaction_type</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
        <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;Purchase&quot;</span><span class="p">,</span> <span class="s2">&quot;Withdrawal&quot;</span><span class="p">,</span> <span class="s2">&quot;Deposit&quot;</span><span class="p">,</span> <span class="s2">&quot;Bill Payment&quot;</span><span class="p">,</span> <span class="s2">&quot;Refund&quot;</span><span class="p">],</span> <span class="kc">None</span>
    <span class="p">]</span>
    <span class="n">transaction_category</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
        <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;Food&quot;</span><span class="p">,</span> <span class="s2">&quot;Entertainment&quot;</span><span class="p">,</span> <span class="s2">&quot;Transport&quot;</span><span class="p">,</span> <span class="s2">&quot;Utilities&quot;</span><span class="p">,</span> <span class="s2">&quot;Rent&quot;</span><span class="p">,</span> <span class="s2">&quot;Other&quot;</span><span class="p">],</span> <span class="kc">None</span>
    <span class="p">]</span>

<span class="c1"># 4. 定义输出解析器:</span>
<span class="n">output_parser</span> <span class="o">=</span> <span class="n">PydanticOutputParser</span><span class="p">(</span><span class="n">pydantic_object</span><span class="o">=</span><span class="n">EnrichedTransactionInformation</span><span class="p">)</span>
<span class="c1"># 以下两行代码用于将生成的交易类型和交易分类添加到 DataFrame 中</span>
<span class="n">df</span><span class="p">[</span><span class="s2">&quot;mistral_transaction_type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">transaction_types</span>
<span class="n">df</span><span class="p">[</span><span class="s2">&quot;mistral_transaction_category&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">transaction_categories</span>
<span class="n">df</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>

<span class="c1"># 5. 定义一个函数，用于修正并移除反斜杠:</span>
<span class="k">def</span> <span class="nf">remove_back_slashes</span><span class="p">(</span><span class="n">string</span><span class="p">):</span>
    <span class="c1"># 双反斜杠用于转义</span>
    <span class="n">cleaned_string</span> <span class="o">=</span> <span class="n">string</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cleaned_string</span>

<span class="c1"># 6. 创建一个 LCEL 链，该链用于修正格式：</span>
<span class="n">chain</span> <span class="o">=</span> <span class="n">prompt</span> <span class="o">|</span> <span class="n">model</span> <span class="o">|</span> <span class="n">StrOutputParser</span><span class="p">()</span> <span class="o">|</span> <span class="n">remove_back_slashes</span> <span class="o">|</span> <span class="n">output_parser</span>
<span class="n">transaction</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;Transaction Description&quot;</span><span class="p">]</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">chain</span><span class="o">.</span><span class="n">invoke</span><span class="p">({</span>
    <span class="s2">&quot;transaction&quot;</span><span class="p">:</span> <span class="n">transaction</span><span class="p">,</span>
    <span class="s2">&quot;format_instructions&quot;</span><span class="p">:</span> <span class="n">output_parser</span><span class="o">.</span><span class="n">get_format_instructions</span><span class="p">(),</span>
<span class="p">})</span>

<span class="c1"># 7. 对整个数据集调用该链:</span>
<span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
<span class="kn">from</span> <span class="nn">tqdm</span> <span class="kn">import</span> <span class="n">tqdm</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">iterrows</span><span class="p">(),</span> <span class="n">total</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">)):</span>
    <span class="n">transaction</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;Transaction Description&quot;</span><span class="p">]</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">chain</span><span class="o">.</span><span class="n">invoke</span><span class="p">({</span>
            <span class="s2">&quot;transaction&quot;</span><span class="p">:</span> <span class="n">transaction</span><span class="p">,</span>
            <span class="s2">&quot;format_instructions&quot;</span><span class="p">:</span> <span class="n">output_parser</span><span class="o">.</span><span class="n">get_format_instructions</span><span class="p">(),</span>
        <span class="p">})</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">EnrichedTransactionInformation</span><span class="p">(</span>
            <span class="n">transaction_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">transaction_category</span><span class="o">=</span><span class="kc">None</span>
        <span class="p">)</span>
    <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

<span class="c1"># 8. 将结果添加到 DataFrame 中，作为交易类型和交易分类的列:</span>
<span class="n">transaction_types</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">transaction_categories</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">results</span><span class="p">:</span>
    <span class="n">transaction_types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">transaction_type</span><span class="p">)</span>
    <span class="n">transaction_categories</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">transaction_category</span><span class="p">)</span>

</pre></div>
</div>
<p>输出：</p>
<div class="pst-scrollable-table-container"><table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Transaction Description</p></th>
<th class="head"><p>transaction_type</p></th>
<th class="head"><p>transaction_category</p></th>
<th class="head"><p>mistral_transaction_type</p></th>
<th class="head"><p>mistral_transaction_category</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>cash deposit at local branch</p></td>
<td><p>Deposit</p></td>
<td><p>Other</p></td>
<td><p>Deposit</p></td>
<td><p>Other</p></td>
</tr>
<tr class="row-odd"><td><p>cash deposit at local branch</p></td>
<td><p>Deposit</p></td>
<td><p>Other</p></td>
<td><p>Deposit</p></td>
<td><p>Other</p></td>
</tr>
<tr class="row-even"><td><p>withdrew money for rent payment</p></td>
<td><p>Withdrawal</p></td>
<td><p>Rent</p></td>
<td><p>Withdrawal</p></td>
<td><p>Rent</p></td>
</tr>
<tr class="row-odd"><td><p>withdrew cash for weekend expenses</p></td>
<td><p>Withdrawal</p></td>
<td><p>Other</p></td>
<td><p>Withdrawal</p></td>
<td><p>Other</p></td>
</tr>
<tr class="row-even"><td><p>purchased books from the bookstore</p></td>
<td><p>Purchase</p></td>
<td><p>Other</p></td>
<td><p>Purchase</p></td>
<td><p>Entertainment</p></td>
</tr>
</tbody>
</table>
</div>
<p>代码解释：</p>
<ol class="arabic simple">
<li><p><strong>导入模块：</strong></p>
<ul class="simple">
<li><p>从 <code class="docutils literal notranslate"><span class="pre">langchain_mistralai.chat_models</span></code> 导入 <code class="docutils literal notranslate"><span class="pre">ChatMistralAI</span></code>，实现了 LangChain 的 Mistral 模型。</p></li>
</ul>
</li>
<li><p><strong>导入输出解析器：</strong></p>
<ul class="simple">
<li><p>从 <code class="docutils literal notranslate"><span class="pre">langchain.output_parsers</span></code> 导入 <code class="docutils literal notranslate"><span class="pre">PydanticOutputParser</span></code> 类，用于基于 Pydantic 模型解析输出。</p></li>
<li><p>同时导入字符串输出解析器，用于处理 Mistral 响应中 JSON 键的反斜杠问题。</p></li>
</ul>
</li>
<li><p><strong>获取 API 密钥：</strong></p>
<ul class="simple">
<li><p>使用 <code class="docutils literal notranslate"><span class="pre">os.environ[&quot;MISTRAL_API_KEY&quot;]</span></code> 从环境变量中获取 Mistral API 密钥。</p></li>
<li><p>在运行笔记本之前必须设置该密钥。</p></li>
</ul>
</li>
<li><p><strong>初始化模型：</strong></p>
<ul class="simple">
<li><p>使用 <code class="docutils literal notranslate"><span class="pre">ChatMistralAI(model=&quot;mistral-small&quot;,</span> <span class="pre">mistral_api_key=mistral_api_key)</span></code> 初始化模型实例。</p></li>
<li><p>这里的 “mistral-small” 是 Mistral 小模型，也称为 Mixtral 8x7b 模型（在 API 中称为 mistral-small）。</p></li>
</ul>
</li>
<li><p><strong>定义提示模板：</strong></p>
<ul class="simple">
<li><p>定义 <code class="docutils literal notranslate"><span class="pre">system_prompt</span></code> 和 <code class="docutils literal notranslate"><span class="pre">user_prompt</span></code> 模板，用于聊天过程中对交易进行分类。</p></li>
</ul>
</li>
<li><p><strong>定义 Pydantic 模型：</strong></p>
<ul class="simple">
<li><p>定义 <code class="docutils literal notranslate"><span class="pre">EnrichedTransactionInformation</span></code> Pydantic 模型，包含两个字段：<code class="docutils literal notranslate"><span class="pre">transaction_type</span></code> 和 <code class="docutils literal notranslate"><span class="pre">transaction_category</span></code>。</p></li>
<li><p>这些字段具有特定的允许值，并且可以为 None，用于确保输出格式正确。</p></li>
</ul>
</li>
<li><p><strong>定义清理函数：</strong></p>
<ul class="simple">
<li><p>定义 <code class="docutils literal notranslate"><span class="pre">remove_back_slashes(string)</span></code> 函数，用于去除字符串中的反斜杠。</p></li>
</ul>
</li>
<li><p><strong>构建 LCEL 链：</strong></p>
<ul class="simple">
<li><p>使用 <code class="docutils literal notranslate"><span class="pre">chain</span> <span class="pre">=</span> <span class="pre">prompt</span> <span class="pre">|</span> <span class="pre">model</span> <span class="pre">|</span> <span class="pre">StrOutputParser()</span> <span class="pre">|</span> <span class="pre">remove_back_slashes</span> <span class="pre">|</span> <span class="pre">output_parser</span></code> 构建链。</p></li>
<li><p>这个链在调用原始输出解析器之前，先经过字符串输出解析器和清理函数处理。</p></li>
</ul>
</li>
<li><p><strong>提取第一条交易描述：</strong></p>
<ul class="simple">
<li><p>使用 <code class="docutils literal notranslate"><span class="pre">transaction</span> <span class="pre">=</span> <span class="pre">df.iloc[0][&quot;Transaction</span> <span class="pre">Description&quot;]</span></code> 从 DataFrame <code class="docutils literal notranslate"><span class="pre">df</span></code> 中提取第一条交易描述（假设 DataFrame 已提前加载）。</p></li>
</ul>
</li>
<li><p><strong>遍历 DataFrame：</strong></p>
<ul class="simple">
<li><p>使用 <code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">i,</span> <span class="pre">row</span> <span class="pre">in</span> <span class="pre">tqdm(df.iterrows(),</span> <span class="pre">total=len(df))</span></code> 遍历 DataFrame 中的每一行，并显示进度条。</p></li>
</ul>
</li>
<li><p><strong>调用链处理：</strong></p>
<ul class="simple">
<li><p>在循环中，通过 <code class="docutils literal notranslate"><span class="pre">result</span> <span class="pre">=</span> <span class="pre">chain.invoke(...)</span></code> 对每条交易调用链进行处理。</p></li>
</ul>
</li>
<li><p><strong>异常处理：</strong></p>
<ul class="simple">
<li><p>如果调用过程中发生异常，则创建一个默认的 <code class="docutils literal notranslate"><span class="pre">EnrichedTransactionInformation</span></code> 对象（字段均为 None），这些将被视为错误，但不会中断处理循环。</p></li>
</ul>
</li>
<li><p><strong>更新 DataFrame：</strong></p>
<ul class="simple">
<li><p>将生成的 <code class="docutils literal notranslate"><span class="pre">transaction_types</span></code> 和 <code class="docutils literal notranslate"><span class="pre">transaction_categories</span></code> 分别作为新列添加到 DataFrame 中，命名为 <code class="docutils literal notranslate"><span class="pre">mistral_transaction_type</span></code> 和 <code class="docutils literal notranslate"><span class="pre">mistral_transaction_category</span></code>。</p></li>
<li><p>最后，使用 <code class="docutils literal notranslate"><span class="pre">df.head()</span></code> 显示更新后的 DataFrame。</p></li>
</ul>
</li>
</ol>
<p>将 Mistral 的响应保存到 DataFrame 中后，就可以将它们与之前定义的交易类别和类型进行比较，以检查 Mistral 的准确性。最基本的 LangChain 评估指标是将预测结果与参考答案进行精确字符串匹配，如果匹配正确则返回 1，错误则返回 0。笔记本中给出了如何实现这一指标的示例，显示 Mistral 的准确率为 77.5%。不过，如果你只是在比较字符串，那么可能不需要在 LangChain 中实现这一过程。</p>
<p>LangChain 的价值在于其标准化和经过测试的方法，利用 LLM 实现更高级的评估器。标签为 <code class="docutils literal notranslate"><span class="pre">labeled_pairwise_string</span></code> 的评估器使用 GPT-4 比较两个输出，并给出选择理由。这类评估器的常见用例是比较来自两个不同提示或模型的输出，尤其是在被测试模型不如 GPT-4 先进时。使用 GPT-4 的这个评估器依然适用于评估 GPT-4 的响应，但你应手动审核其推理和评分以确保其表现良好：如果 GPT-4 在某个任务上表现不佳，那么它在评估该任务时也可能表现不佳。</p>
<p>在笔记本中，同一交易分类任务又以 <code class="docutils literal notranslate"><span class="pre">model</span> <span class="pre">=</span> <span class="pre">ChatOpenAI(model=&quot;gpt-3.5-turbo-1106&quot;,</span> <span class="pre">model_kwargs={&quot;response_format&quot;:</span> <span class="pre">{&quot;type&quot;:</span> <span class="pre">&quot;json_object&quot;}})</span></code> 的模型重新运行。现在可以对 Mistral 和 GPT-3.5 的响应进行成对比较，如以下示例所示。从输出中你可以看到给出分数的推理理由。</p>
<p>输入：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 使用 LangChain 评估器对答案进行评估：</span>
<span class="kn">from</span> <span class="nn">langchain.evaluation</span> <span class="kn">import</span> <span class="n">load_evaluator</span>
<span class="n">evaluator</span> <span class="o">=</span> <span class="n">load_evaluator</span><span class="p">(</span><span class="s2">&quot;labeled_pairwise_string&quot;</span><span class="p">)</span>

<span class="c1"># 从 DataFrame 中获取第一行数据</span>
<span class="n">row</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">transaction</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;Transaction Description&quot;</span><span class="p">]</span>
<span class="n">gpt3pt5_category</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;gpt3.5_transaction_category&quot;</span><span class="p">]</span>
<span class="n">gpt3pt5_type</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;gpt3.5_transaction_type&quot;</span><span class="p">]</span>
<span class="n">mistral_category</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;mistral_transaction_category&quot;</span><span class="p">]</span>
<span class="n">mistral_type</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;mistral_transaction_type&quot;</span><span class="p">]</span>
<span class="n">reference_category</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;transaction_category&quot;</span><span class="p">]</span>
<span class="n">reference_type</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;transaction_type&quot;</span><span class="p">]</span>

<span class="c1"># 将数据转换为 JSON 格式供评估器使用：</span>
<span class="n">gpt3pt5_data</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span><span class="se">{{</span>
<span class="s2">&quot;transaction_category&quot;: &quot;</span><span class="si">{</span><span class="n">gpt3pt5_category</span><span class="si">}</span><span class="s2">&quot;,</span>
<span class="s2">&quot;transaction_type&quot;: &quot;</span><span class="si">{</span><span class="n">gpt3pt5_type</span><span class="si">}</span><span class="s2">&quot;</span>
<span class="se">}}</span><span class="s2">&quot;&quot;&quot;</span>
<span class="n">mistral_data</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span><span class="se">{{</span>
<span class="s2">&quot;transaction_category&quot;: &quot;</span><span class="si">{</span><span class="n">mistral_category</span><span class="si">}</span><span class="s2">&quot;,</span>
<span class="s2">&quot;transaction_type&quot;: &quot;</span><span class="si">{</span><span class="n">mistral_type</span><span class="si">}</span><span class="s2">&quot;</span>
<span class="se">}}</span><span class="s2">&quot;&quot;&quot;</span>
<span class="n">reference_data</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span><span class="se">{{</span>
<span class="s2">&quot;transaction_category&quot;: &quot;</span><span class="si">{</span><span class="n">reference_category</span><span class="si">}</span><span class="s2">&quot;,</span>
<span class="s2">&quot;transaction_type&quot;: &quot;</span><span class="si">{</span><span class="n">reference_type</span><span class="si">}</span><span class="s2">&quot;</span>
<span class="se">}}</span><span class="s2">&quot;&quot;&quot;</span>

<span class="c1"># 为评估器设置上下文提示输入：</span>
<span class="n">input_prompt</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;You are an expert at analyzing bank</span>
<span class="s2">transactions,</span>
<span class="s2">you will be categorizing a single transaction.</span>
<span class="s2">Always return a transaction type and category: do not</span>
<span class="s2">return None.</span>
<span class="s2">Format Instructions:</span>
<span class="si">{format_instructions}</span>
<span class="s2">Transaction Text:</span>
<span class="si">{transaction}</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="c1"># 将评估结果附加到对应的列表中：</span>
<span class="n">transaction_types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">transaction_type_score</span><span class="p">)</span>
<span class="n">transaction_categories</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">transaction_category_score</span><span class="p">)</span>

<span class="c1"># 计算准确率得分：</span>
<span class="n">accuracy_score</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">transaction_type_score</span><span class="p">,</span> <span class="n">transaction_category_score</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">transaction_types</span><span class="p">,</span> <span class="n">transaction_categories</span><span class="p">):</span>
    <span class="n">accuracy_score</span> <span class="o">+=</span> <span class="n">transaction_type_score</span><span class="p">[</span><span class="s1">&#39;score&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">transaction_category_score</span><span class="p">[</span><span class="s1">&#39;score&#39;</span><span class="p">]</span>
<span class="n">accuracy_score</span> <span class="o">=</span> <span class="n">accuracy_score</span> <span class="o">/</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">transaction_types</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Accuracy score: </span><span class="si">{</span><span class="n">accuracy_score</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># 使用评估器进行字符串对比评估：</span>
<span class="n">evaluator</span><span class="o">.</span><span class="n">evaluate_string_pairs</span><span class="p">(</span>
    <span class="n">prediction</span><span class="o">=</span><span class="n">gpt3pt5_data</span><span class="p">,</span>
    <span class="n">prediction_b</span><span class="o">=</span><span class="n">mistral_data</span><span class="p">,</span>
    <span class="nb">input</span><span class="o">=</span><span class="n">input_prompt</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
        <span class="n">format_instructions</span><span class="o">=</span><span class="n">output_parser</span><span class="o">.</span><span class="n">get_format_instructions</span><span class="p">(),</span>
        <span class="n">transaction</span><span class="o">=</span><span class="n">transaction</span>
    <span class="p">),</span>
    <span class="n">reference</span><span class="o">=</span><span class="n">reference_data</span><span class="p">,</span>
<span class="p">)</span>

</pre></div>
</div>
<p>输出：</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
<span class="w">  </span><span class="nt">&quot;reasoning&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;Both Assistant A and Assistant B provided the exact same response to the user&#39;s question. Their responses are both helpful, relevant, correct, and demonstrate depth of thought. They both correctly identified the transaction type as \&quot;Deposit\&quot; and the transaction category as \&quot;Other\&quot; based on the transaction text provided by the user. Both responses are also well-formatted according to the JSON schema provided by the user. Therefore, it&#39;s a tie between the two assistants.\n\nFinal Verdict: [[C]]&quot;</span><span class="p">,</span>
<span class="w">  </span><span class="nt">&quot;value&quot;</span><span class="p">:</span><span class="w"> </span><span class="kc">null</span><span class="p">,</span>
<span class="w">  </span><span class="nt">&quot;score&quot;</span><span class="p">:</span><span class="w"> </span><span class="mf">0.5</span>
<span class="p">}</span>
</pre></div>
</div>
<ol class="arabic simple">
<li><p><strong>evaluator = load_evaluator(“labeled_pairwise_string”)</strong><br />
这是一个辅助函数，可用于通过名称加载任何 LangChain 评估器。在本例中，它加载的是 labeled_pairwise_string 评估器。</p></li>
<li><p><strong>row = df.iloc[0]</strong><br />
这一行以及随后的七行代码获取了 DataFrame 中的第一行数据，并提取所需的各列值，包括交易描述、Mistral 和 GPT-3.5 的交易类别和类型。这里展示的是单个交易，但这段代码可以很容易地通过遍历每个交易（例如使用 <code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">i,</span> <span class="pre">row</span> <span class="pre">in</span> <span class="pre">tqdm(df.iterrows(),</span> <span class="pre">total=len(df)):</span></code>）来运行，正如后续笔记本中所示。</p></li>
<li><p><strong>gpt3pt5_data = f”””{{</strong><br />
为了使用成对比较评估器，我们需要将结果以正确的格式传递给提示。这一步对 Mistral、GPT-3.5 以及参考数据均进行了格式化处理。</p></li>
<li><p><strong>input_prompt = “””You are an expert…</strong><br />
另一个需要正确设置格式的是提示。为了获得准确的评估分数，评估器需要看到为任务提供的指令。</p></li>
<li><p><strong>evaluator.evaluate_string_pairs(…</strong><br />
剩下的就是运行评估器：通过传入 prediction 和 prediction_b（分别代表 GPT-3.5 和 Mistral 的结果），以及输入提示和作为真值的参考数据来进行评估。</p></li>
<li><p><strong>后续循环处理</strong><br />
在笔记本中，这段代码之后还有一个示例，展示了如何遍历 DataFrame 中的每一行，对每条数据运行评估器，并将评估结果和推理保存回 DataFrame。</p></li>
</ol>
<hr class="docutils" />
<p>这个示例展示了如何使用 LangChain 评估器，但实际上有许多不同类型的评估器可供选择。  例如，字符串距离（Levenshtein）或嵌入距离评估器通常用于答案与参考答案不完全匹配的场景，此时只需要语义上足够接近。</p>
<ul class="simple">
<li><p><strong>Levenshtein 距离</strong>：允许基于将预测文本转换为参考文本所需的单字符编辑数进行模糊匹配。</p></li>
<li><p><strong>嵌入距离</strong>：利用向量（在第5章中有介绍）来计算答案与参考答案之间的相似度。</p></li>
</ul>
<p>另一种常用的评估器是成对比较评估器，它利用更智能的模型（如 GPT-4）来比较两个不同的提示或模型。  这种比较非常有用，因为它为每次比较提供了推理过程，有助于调试为何某种方法比另一种方法更优。  代码中展示了一个使用成对比较评估器来检查 GPT-3.5-turbo 与 Mixtral 8x7b 准确率的示例。</p>
<blockquote>
<div><p>评估质量<br />
如果没有定义适当的评价指标来衡量成功，就很难判断对提示或整个系统的改动究竟是在提升还是在损害响应质量。如果能够利用诸如 GPT-4 这样的智能模型自动化评价指标，就可以更快地迭代改进结果，而无需耗费大量成本或时间进行人工审查。</p>
</div></blockquote>
</section>
<section id="openai">
<h2>OpenAI 函数调用<a class="headerlink" href="#openai" title="Link to this heading">#</a></h2>
<p>函数调用为输出解析器提供了一种替代方法，利用经过微调的 OpenAI 模型。这些模型能够识别何时应执行某个函数，并生成一个包含预定义函数名称及其参数的 JSON 响应。其几个主要用例包括：</p>
<ul class="simple">
<li><p><strong>设计复杂的聊天机器人</strong><br />
能够组织和管理日程。例如，你可以定义一个用于安排会议的函数：<br />
<code class="docutils literal notranslate"><span class="pre">schedule_meeting(date:</span> <span class="pre">str,</span> <span class="pre">time:</span> <span class="pre">str,</span> <span class="pre">attendees:</span> <span class="pre">List[str])</span></code></p></li>
<li><p><strong>将自然语言转换为可执行的 API 调用</strong><br />
像“打开走廊灯”这样的指令可以转换为 <code class="docutils literal notranslate"><span class="pre">control_device(device:</span> <span class="pre">str,</span> <span class="pre">action:</span> <span class="pre">'on'</span> <span class="pre">|</span> <span class="pre">'off')</span></code>，以便与家庭自动化 API 进行交互。</p></li>
<li><p><strong>提取结构化数据</strong><br />
这可以通过定义函数来实现，例如 <code class="docutils literal notranslate"><span class="pre">extract_contextual_data(context:</span> <span class="pre">str,</span> <span class="pre">data_points:</span> <span class="pre">List[str])</span></code> 或 <code class="docutils literal notranslate"><span class="pre">search_database(query:</span> <span class="pre">str)</span></code>。</p></li>
</ul>
<p>每个在函数调用中使用的函数都需要一个适当的 JSON schema。让我们通过一个 OpenAI 包的示例来进行探索：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">openai</span> <span class="kn">import</span> <span class="n">OpenAI</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">from</span> <span class="nn">os</span> <span class="kn">import</span> <span class="n">getenv</span>

<span class="k">def</span> <span class="nf">schedule_meeting</span><span class="p">(</span><span class="n">date</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">attendees</span><span class="p">):</span>
    <span class="c1"># 连接到日历服务：</span>
    <span class="k">return</span> <span class="p">{</span> 
        <span class="s2">&quot;event_id&quot;</span><span class="p">:</span> <span class="s2">&quot;1234&quot;</span><span class="p">,</span> 
        <span class="s2">&quot;status&quot;</span><span class="p">:</span> <span class="s2">&quot;Meeting scheduled successfully!&quot;</span><span class="p">,</span>
        <span class="s2">&quot;date&quot;</span><span class="p">:</span> <span class="n">date</span><span class="p">,</span> 
        <span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="n">time</span><span class="p">,</span> 
        <span class="s2">&quot;attendees&quot;</span><span class="p">:</span> <span class="n">attendees</span> 
    <span class="p">}</span>

<span class="n">OPENAI_FUNCTIONS</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;schedule_meeting&quot;</span><span class="p">:</span> <span class="n">schedule_meeting</span>
<span class="p">}</span>
</pre></div>
</div>
<p>在导入 OpenAI 和 json 后，你将创建一个名为 <code class="docutils literal notranslate"><span class="pre">schedule_meeting</span></code> 的函数。该函数是一个模拟示例，模拟了安排会议的过程，并返回诸如 <code class="docutils literal notranslate"><span class="pre">event_id</span></code>、<code class="docutils literal notranslate"><span class="pre">date</span></code>、<code class="docutils literal notranslate"><span class="pre">time</span></code> 和 <code class="docutils literal notranslate"><span class="pre">attendees</span></code> 等细节。接着，创建一个 <code class="docutils literal notranslate"><span class="pre">OPENAI_FUNCTIONS</span></code> 字典，将函数名称映射到实际函数，便于引用。</p>
<p>接下来，定义一个 functions 列表，该列表提供函数的 JSON 模式。该模式包括函数的名称、简要描述以及所需的参数，从而指导 LLM 如何与之交互：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 我们预定义的函数 JSON 模式:</span>
<span class="n">functions</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">{</span>
        <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;function&quot;</span><span class="p">,</span>
        <span class="s2">&quot;function&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;object&quot;</span><span class="p">,</span>
            <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;schedule_meeting&quot;</span><span class="p">,</span>
            <span class="s2">&quot;description&quot;</span><span class="p">:</span> <span class="s2">&quot;在指定日期和时间为指定参会者安排会议&quot;</span><span class="p">,</span>
            <span class="s2">&quot;parameters&quot;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;object&quot;</span><span class="p">,</span>
                <span class="s2">&quot;properties&quot;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="s2">&quot;date&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;string&quot;</span><span class="p">,</span> <span class="s2">&quot;format&quot;</span><span class="p">:</span> <span class="s2">&quot;date&quot;</span><span class="p">},</span>
                    <span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;string&quot;</span><span class="p">,</span> <span class="s2">&quot;format&quot;</span><span class="p">:</span> <span class="s2">&quot;time&quot;</span><span class="p">},</span>
                    <span class="s2">&quot;attendees&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;array&quot;</span><span class="p">,</span> <span class="s2">&quot;items&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;string&quot;</span><span class="p">}}</span>
                <span class="p">},</span>
                <span class="s2">&quot;required&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;date&quot;</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="s2">&quot;attendees&quot;</span><span class="p">]</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">]</span>

</pre></div>
</div>
<blockquote>
<div><p>指定格式<br />
使用 OpenAI 模型进行函数调用时，请务必定义详细的 JSON 模式（包括名称和描述）。  这相当于为函数提供了蓝图，引导模型理解何时以及如何正确调用该函数。</p>
</div></blockquote>
<p>在定义好函数之后，让我们发起一个 OpenAI API 请求。首先设置一个包含用户查询的消息列表。然后，使用 OpenAI 客户端对象将这条消息和函数模式发送给模型。LLM 分析对话后，会判断是否需要触发函数，并提供函数名称和参数。从 LLM 的响应中解析出 function 和 function_args。接着，执行该函数，并将其结果重新添加到对话中。最后，再次调用模型，以便生成整个过程的用户友好总结。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">openai</span> <span class="kn">import</span> <span class="n">OpenAI</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">from</span> <span class="nn">os</span> <span class="kn">import</span> <span class="n">getenv</span>

<span class="c1">#初始化 OpenAI 客户端</span>
<span class="n">client</span> <span class="o">=</span> <span class="n">OpenAI</span><span class="p">(</span><span class="n">api_key</span><span class="o">=</span><span class="n">getenv</span><span class="p">(</span><span class="s2">&quot;OPENAI_API_KEY&quot;</span><span class="p">))</span>

<span class="c1">#开始对话：</span>
<span class="n">messages</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">{</span>
        <span class="s2">&quot;role&quot;</span><span class="p">:</span> <span class="s2">&quot;user&quot;</span><span class="p">,</span>
        <span class="s2">&quot;content&quot;</span><span class="p">:</span> <span class="s1">&#39;&#39;&#39;Schedule a meeting on 2023-11-01 at 14:00</span>
<span class="s1">with Alice and Bob.&#39;&#39;&#39;</span><span class="p">,</span>
    <span class="p">}</span>
<span class="p">]</span>

<span class="c1">#将对话和函数模式发送给模型：</span>
<span class="n">response</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">chat</span><span class="o">.</span><span class="n">completions</span><span class="o">.</span><span class="n">create</span><span class="p">(</span>
    <span class="n">model</span><span class="o">=</span><span class="s2">&quot;gpt-3.5-turbo-1106&quot;</span><span class="p">,</span>
    <span class="n">messages</span><span class="o">=</span><span class="n">messages</span><span class="p">,</span>
    <span class="n">tools</span><span class="o">=</span><span class="n">functions</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">response</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="n">choices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">message</span>

<span class="c1">#检查模型是否想调用我们的函数：</span>
<span class="k">if</span> <span class="n">response</span><span class="o">.</span><span class="n">tool_calls</span><span class="p">:</span>
    <span class="c1"># 获取第一个函数调用：</span>
    <span class="n">first_tool_call</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="n">tool_calls</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># 获取要调用的函数名称和参数：</span>
    <span class="n">function_name</span> <span class="o">=</span> <span class="n">first_tool_call</span><span class="o">.</span><span class="n">function</span><span class="o">.</span><span class="n">name</span>
    <span class="n">function_args</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">first_tool_call</span><span class="o">.</span><span class="n">function</span><span class="o">.</span><span class="n">arguments</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;This is the function name: &quot;</span><span class="p">,</span> <span class="n">function_name</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;These are the function arguments: &quot;</span><span class="p">,</span> <span class="n">function_args</span><span class="p">)</span>
</pre></div>
</div>
<p>​</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 根据函数名称找到对应的函数：</span>
<span class="n">function</span> <span class="o">=</span> <span class="n">OPENAI_FUNCTIONS</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">function_name</span><span class="p">)</span>
<span class="k">if</span> <span class="ow">not</span> <span class="n">function</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Function </span><span class="si">{</span><span class="n">function_name</span><span class="si">}</span><span class="s2"> not found.&quot;</span><span class="p">)</span>

<span class="c1"># 调用函数：</span>
<span class="n">function_response</span> <span class="o">=</span> <span class="n">function</span><span class="p">(</span><span class="o">**</span><span class="n">function_args</span><span class="p">)</span>

<span class="c1"># 将函数的响应结果添加回对话中：</span>
<span class="n">messages</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
    <span class="p">{</span>
        <span class="s2">&quot;role&quot;</span><span class="p">:</span> <span class="s2">&quot;function&quot;</span><span class="p">,</span>
        <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;schedule_meeting&quot;</span><span class="p">,</span>
        <span class="s2">&quot;content&quot;</span><span class="p">:</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">function_response</span><span class="p">),</span>
    <span class="p">}</span>
<span class="p">)</span>

<span class="c1"># 让模型生成一个用户友好的总结：</span>
<span class="n">second_response</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">chat</span><span class="o">.</span><span class="n">completions</span><span class="o">.</span><span class="n">create</span><span class="p">(</span>
    <span class="n">model</span><span class="o">=</span><span class="s2">&quot;gpt-3.5-turbo-0613&quot;</span><span class="p">,</span> 
    <span class="n">messages</span><span class="o">=</span><span class="n">messages</span>
<span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">second_response</span><span class="o">.</span><span class="n">choices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">message</span><span class="o">.</span><span class="n">content</span><span class="p">)</span>
</pre></div>
</div>
<p>输出：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">These</span> <span class="n">are</span> <span class="n">the</span> <span class="n">function</span> <span class="n">arguments</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;date&#39;</span><span class="p">:</span> <span class="s1">&#39;2023-11-01&#39;</span><span class="p">,</span> <span class="s1">&#39;time&#39;</span><span class="p">:</span> <span class="s1">&#39;14:00&#39;</span><span class="p">,</span><span class="s1">&#39;attendees&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;Alice&#39;</span><span class="p">,</span> <span class="s1">&#39;Bob&#39;</span><span class="p">]}</span>
<span class="n">This</span> <span class="ow">is</span> <span class="n">the</span> <span class="n">function</span> <span class="n">name</span><span class="p">:</span> <span class="n">schedule_meeting</span>
<span class="n">I</span> <span class="n">have</span> <span class="n">scheduled</span> <span class="n">a</span> <span class="n">meeting</span> <span class="n">on</span> <span class="mi">2023</span><span class="o">-</span><span class="mi">11</span><span class="o">-</span><span class="mi">01</span> <span class="n">at</span> <span class="mi">14</span><span class="p">:</span><span class="mi">00</span> <span class="k">with</span> <span class="n">Alice</span> <span class="ow">and</span> <span class="n">Bob</span><span class="o">.</span>
<span class="n">The</span> <span class="n">event</span> <span class="n">ID</span> <span class="ow">is</span> <span class="mf">1234.</span>
</pre></div>
</div>
<ul>
<li><p><strong>多个函数：</strong><br />
LLM 可以调用多个函数。</p></li>
<li><p><strong>明确参数：</strong><br />
OpenAI 可能会虚构函数参数，因此在系统消息中需要更明确地说明，以防止这种情况发生。</p></li>
<li><p><strong>function_call 参数设置方式：</strong></p>
<ul>
<li><p><strong>强制调用特定函数：</strong><br />
设置 <code class="docutils literal notranslate"><span class="pre">tool_choice</span></code> 为</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;function&quot;</span><span class="p">,</span><span class="w"> </span><span class="nt">&quot;function&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="nt">&quot;name&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;my_function&quot;</span><span class="p">}}</span>
</pre></div>
</div>
</li>
<li><p><strong>用户消息无需函数调用：</strong><br />
设置 <code class="docutils literal notranslate"><span class="pre">tool_choice</span></code> 为 <code class="docutils literal notranslate"><span class="pre">&quot;none&quot;</span></code>。</p></li>
<li><p><strong>默认设置（自动选择）：</strong><br />
默认设置为 <code class="docutils literal notranslate"><span class="pre">tool_choice:</span> <span class="pre">&quot;auto&quot;</span></code>，模型会自主决定是否调用函数以及调用哪个函数。</p></li>
</ul>
</li>
</ul>
</section>
<section id="prompt-chaining">
<h2>Prompt Chaining<a class="headerlink" href="#prompt-chaining" title="Link to this heading">#</a></h2>
<p>你会发现，在一个提示中完成单个任务往往是不可能的。<br />
你可以利用提示链（prompt chaining）的方式，这种方式涉及将多个提示的输入/输出与专门定制的 LLM 提示相结合，从而逐步构建出一个完整的想法。</p>
<p>举个例子，假设一家电影公司希望部分自动化他们的电影制作过程。这个过程可以拆分为几个关键组成部分，例如：</p>
<ul class="simple">
<li><p>角色创建</p></li>
<li><p>剧情生成</p></li>
<li><p>场景/世界构建</p></li>
</ul>
<p><img alt="seq-chain" src="../_images/seq-chain.png" /></p>
<section id="sequential-chain">
<h3>Sequential Chain<a class="headerlink" href="#sequential-chain" title="Link to this heading">#</a></h3>
<p>让我们将任务分解成多个链，然后再将它们重新组合为一个单独的链：</p>
<ul class="simple">
<li><p><strong>character_generation_chain</strong><br />
负责根据给定的“genre”生成三个到五个角色。</p></li>
<li><p><strong>plot_generation_chain</strong><br />
根据“characters”和“genre”这两个关键字生成短篇故事的情节。</p></li>
<li><p><strong>scene_generation_chain</strong><br />
负责生成情节中未包含的其他场景，将整个故事分解成多个有效的场景。</p></li>
</ul>
<p>下面我们从创建三个独立的 <code class="docutils literal notranslate"><span class="pre">ChatPromptTemplate</span></code> 变量开始，每个链对应一个模板：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">langchain_core.prompts.chat</span> <span class="kn">import</span> <span class="n">ChatPromptTemplate</span>

<span class="n">character_generation_prompt</span> <span class="o">=</span> <span class="n">ChatPromptTemplate</span><span class="o">.</span><span class="n">from_template</span><span class="p">(</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;I want you to brainstorm three to five characters for my short story. The</span>
<span class="sd">genre is {genre}. Each character must have a Name and a Biography.</span>
<span class="sd">You must provide a name and biography for each character, this is very</span>
<span class="sd">important!</span>
<span class="sd">---</span>
<span class="sd">Example response:</span>
<span class="sd">Name: CharWiz, Biography: A wizard who is a master of magic.</span>
<span class="sd">Name: CharWar, Biography: A warrior who is a master of the sword.</span>
<span class="sd">---</span>
<span class="sd">Characters: &quot;&quot;&quot;</span>
<span class="p">)</span>

<span class="n">plot_generation_prompt</span> <span class="o">=</span> <span class="n">ChatPromptTemplate</span><span class="o">.</span><span class="n">from_template</span><span class="p">(</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Given the following characters and the genre, create an effective</span>
<span class="sd">plot for a short story:</span>
<span class="sd">Characters:</span>
<span class="sd">{characters}</span>
<span class="sd">---</span>
<span class="sd">Genre: {genre}</span>
<span class="sd">---</span>
<span class="sd">Plot: &quot;&quot;&quot;</span>
<span class="p">)</span>

<span class="n">scene_generation_plot_prompt</span> <span class="o">=</span> <span class="n">ChatPromptTemplate</span><span class="o">.</span><span class="n">from_template</span><span class="p">(</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Act as an effective content creator.</span>
<span class="sd">Given multiple characters and a plot, you are responsible for</span>
<span class="sd">generating the various scenes for each act.</span>
<span class="sd">You must decompose the plot into multiple effective scenes:</span>
<span class="sd">---</span>
<span class="sd">Characters:</span>
<span class="sd">{characters}</span>
<span class="sd">---</span>
<span class="sd">Genre: {genre}</span>
<span class="sd">---</span>
<span class="sd">Plot: {plot}</span>
<span class="sd">---</span>
<span class="sd">Example response:</span>
<span class="sd">Scenes:</span>
<span class="sd">Scene 1: Some text here.</span>
<span class="sd">Scene 2: Some text here.</span>
<span class="sd">Scene 3: Some text here.</span>
<span class="sd">----</span>
<span class="sd">Scenes: &quot;&quot;&quot;</span>
<span class="p">)</span>
</pre></div>
</div>
<p>注意，由于这些提示模板从角色生成到情节生成再到场景生成的过程中，逐步添加了前一步骤的额外占位符变量，那么问题来了：如何确保这些额外的字符串（例如角色信息和情节内容）能传递到下游的 <code class="docutils literal notranslate"><span class="pre">ChatPromptTemplate</span></code> 变量中？</p>
<p>这通常可以通过链式调用实现，也就是将一个链的输出作为下一个链的输入，从而确保所有必要的数据都能正确地传递和使用。</p>
</section>
</section>
<section id="document-chains">
<h2>Document Chains<a class="headerlink" href="#document-chains" title="Link to this heading">#</a></h2>
<p>假设在你提交生成的故事之前，当地出版社要求你提供一个基于所有角色剧本的摘要。由于上下文长度的限制，这个任务需要对大量文本进行处理，这正是 Document Chains 的一个理想用例。</p>
<p>在深入代码之前，我们先了解一下整体流程：<br />
该脚本对一系列场景文本进行摘要处理。请确保已安装 Pandas（使用 <code class="docutils literal notranslate"><span class="pre">pip</span> <span class="pre">install</span> <span class="pre">pandas</span></code>）。</p>
<hr class="docutils" />
<p>首先，导入所需的工具：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">langchain_text_splitters</span> <span class="kn">import</span> <span class="n">CharacterTextSplitter</span>
<span class="kn">from</span> <span class="nn">langchain.chains.summarize</span> <span class="kn">import</span> <span class="n">load_summarize_chain</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
</pre></div>
</div>
<ul class="simple">
<li><p><strong>CharacterTextSplitter</strong> 和 <strong>load_summarize_chain</strong> 来自 LangChain 包，用于文本处理。</p></li>
<li><p><strong>Pandas</strong>（以 <code class="docutils literal notranslate"><span class="pre">pd</span></code> 导入）用于数据操作。</p></li>
</ul>
<p>接下来，处理你的数据：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">generated_scenes</span><span class="p">)</span>

</pre></div>
</div>
<p>这行代码将 <code class="docutils literal notranslate"><span class="pre">generated_scenes</span></code> 转换为 Pandas DataFrame，使原始场景数据以表格格式呈现，便于后续处理。</p>
<p>然后，合并所有文本：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">all_character_script_text</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">character_script</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>

</pre></div>
</div>
<p>这行代码将 DataFrame 中的 <code class="docutils literal notranslate"><span class="pre">character_script</span></code> 列转换为一个列表，并用换行符连接每个条目，生成包含所有角色剧本的单一文本字符串。</p>
<p>准备文本以进行摘要处理：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">text_splitter</span> <span class="o">=</span> <span class="n">CharacterTextSplitter</span><span class="o">.</span><span class="n">from_tiktoken_encoder</span><span class="p">(</span>
    <span class="n">chunk_size</span><span class="o">=</span><span class="mi">1500</span><span class="p">,</span> <span class="n">chunk_overlap</span><span class="o">=</span><span class="mi">200</span>
<span class="p">)</span>
<span class="n">docs</span> <span class="o">=</span> <span class="n">text_splitter</span><span class="o">.</span><span class="n">create_documents</span><span class="p">([</span><span class="n">all_character_script_text</span><span class="p">])</span>

</pre></div>
</div>
<p>这里，利用 <code class="docutils literal notranslate"><span class="pre">from_tiktoken_encoder</span></code> 方法创建一个 <code class="docutils literal notranslate"><span class="pre">CharacterTextSplitter</span></code> 实例，并指定文本块大小及重叠部分。接着使用该分割器将合并后的文本分割成适合摘要处理的文档块。</p>
<p>设置摘要工具：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">chain</span> <span class="o">=</span> <span class="n">load_summarize_chain</span><span class="p">(</span><span class="n">llm</span><span class="o">=</span><span class="n">model</span><span class="p">,</span> <span class="n">chain_type</span><span class="o">=</span><span class="s2">&quot;map_reduce&quot;</span><span class="p">)</span>

</pre></div>
</div>
<p>这行代码使用 map-reduce 风格的摘要链，通过调用 <code class="docutils literal notranslate"><span class="pre">load_summarize_chain</span></code> 函数来加载摘要链，并将聊天模型传入其中。</p>
<p>运行摘要过程：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">summary</span> <span class="o">=</span> <span class="n">chain</span><span class="o">.</span><span class="n">invoke</span><span class="p">(</span><span class="n">docs</span><span class="p">)</span>

</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">invoke</span></code> 方法对先前分割的文本块执行摘要处理，并将结果存储在 <code class="docutils literal notranslate"><span class="pre">summary</span></code> 变量中。</p>
<p>最后，打印摘要结果：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">summary</span><span class="p">[</span><span class="s1">&#39;output_text&#39;</span><span class="p">])</span>

</pre></div>
</div>
<p>整体脚本如下：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">langchain.text_splitter</span> <span class="kn">import</span> <span class="n">CharacterTextSplitter</span>
<span class="kn">from</span> <span class="nn">langchain.chains.summarize</span> <span class="kn">import</span> <span class="n">load_summarize_chain</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>

<span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">generated_scenes</span><span class="p">)</span>
<span class="n">all_character_script_text</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">character_script</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>

<span class="n">text_splitter</span> <span class="o">=</span> <span class="n">CharacterTextSplitter</span><span class="o">.</span><span class="n">from_tiktoken_encoder</span><span class="p">(</span>
    <span class="n">chunk_size</span><span class="o">=</span><span class="mi">1500</span><span class="p">,</span> <span class="n">chunk_overlap</span><span class="o">=</span><span class="mi">200</span>
<span class="p">)</span>
<span class="n">docs</span> <span class="o">=</span> <span class="n">text_splitter</span><span class="o">.</span><span class="n">create_documents</span><span class="p">([</span><span class="n">all_character_script_text</span><span class="p">])</span>

<span class="n">chain</span> <span class="o">=</span> <span class="n">load_summarize_chain</span><span class="p">(</span><span class="n">llm</span><span class="o">=</span><span class="n">model</span><span class="p">,</span> <span class="n">chain_type</span><span class="o">=</span><span class="s2">&quot;map_reduce&quot;</span><span class="p">)</span>
<span class="n">summary</span> <span class="o">=</span> <span class="n">chain</span><span class="o">.</span><span class="n">invoke</span><span class="p">(</span><span class="n">docs</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">summary</span><span class="p">[</span><span class="s1">&#39;output_text&#39;</span><span class="p">])</span>

</pre></div>
</div>
<p>输出示例：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">Aurora</span> <span class="ow">and</span> <span class="n">Magnus</span> <span class="n">agree</span> <span class="n">to</span> <span class="n">retrieve</span> <span class="n">a</span> <span class="n">hidden</span> <span class="n">artifact</span><span class="p">,</span> <span class="ow">and</span> <span class="n">they</span> <span class="n">enter</span> <span class="n">an</span> <span class="n">ancient</span> <span class="n">library</span> <span class="n">to</span> <span class="n">find</span> <span class="n">a</span> <span class="n">book</span> <span class="n">that</span> <span class="n">will</span> <span class="n">guide</span> <span class="n">them</span> <span class="n">to</span> <span class="n">the</span> <span class="n">relic</span><span class="o">...</span>

</pre></div>
</div>
<p>需要注意的是，尽管这里使用了 <code class="docutils literal notranslate"><span class="pre">map_reduce</span></code> 链，但 LangChain 中针对 Document 对象的处理实际上有四个核心链。<code class="docutils literal notranslate"><span class="pre">invoke</span></code> 方法会在之前准备好的文本块上执行摘要处理，并将结果存储到变量中。</p>
</section>
<section id="id6">
<h2>参考<a class="headerlink" href="#id6" title="Link to this heading">#</a></h2>
<ol class="arabic simple">
<li><p>提示词可视化 <a class="reference external" href="https://show.langgpt.ai/">PromptShow</a></p></li>
<li><p><a class="reference external" href="https://langgptai.feishu.cn/wiki/Ovu4wuiAIiENUskIucccTHd0nIc">LangGPT 结构化提示词</a></p></li>
</ol>
</section>
</section>


                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="prompts-examples.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">上一页</p>
        <p class="prev-next-title">提示词案例分析</p>
      </div>
    </a>
    <a class="right-next"
       href="good-examples.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">下一页</p>
        <p class="prev-next-title">提示词案例分析</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <dialog id="pst-secondary-sidebar-modal"></dialog>
                <div id="pst-secondary-sidebar" class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> 目录
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id1">LangChain简介</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id2">安装与准备</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id3">LangChain 提示词模板</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id4">为什么使用LangChain</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#langchain-lcel">LangChain 表达式语言（LCEL）</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#prompttemplate">在聊天模型中使用 PromptTemplate</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id5">输出解析器</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#openai-json">openai 原生支持json输出</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#langchain-evals">LangChain Evals</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#openai">OpenAI 函数调用</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#prompt-chaining">Prompt Chaining</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#sequential-chain">Sequential Chain</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#document-chains">Document Chains</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id6">参考</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
作者： 高志军
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright Zhijun Gao.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script defer src="../_static/scripts/bootstrap.js?digest=26a4bc78f4c0ddb94549"></script>
<script defer src="../_static/scripts/pydata-sphinx-theme.js?digest=26a4bc78f4c0ddb94549"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>